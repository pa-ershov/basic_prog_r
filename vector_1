# Векторы часть 1

# Создание вектора

x <- vector(length = 2)
x[1] <- 5
x[2] <- 8
x

# Функция создания вектора
y <- c(5, 8)
y

# Функция может быть вложенной
y <- c(x, 1, c(3, 4), x, NA)

# Функция seq - создание с определенным шагом из последовательности
z <- seq(1, 2, by = 0.25)
z
# [1] 1.00 1.25 1.50 1.75 2.00

# С определенным количеством элементов - автоматически рассчитывает шаг
seq(3, 4, length.out = 5)
# [1] 3.00 3.25 3.50 3.75 4.00

# Аргумент можно не указывать целиком
seq(3, 4, length = 5)
# [1] 3.00 3.25 3.50 3.75 4.00

# Повторение векторов
# три раза
rep(1:3, times = 3)
# [1] 1 2 3 1 2 3 1 2 3
# каждого элемента
rep(1:3, each = 4)
# [1] 1 1 1 1 2 2 2 2 3 3 3 3
rep(1:3, lenght.out = 5)


# Сравнение числе с разным количеством знаков после запятой
all.equal(0.1 + 0.05, 0.15)
# [1] TRUE

# Создать вектор, содержащий трети и седьмые части, удалить повторяющиеся элементы и упорядочить по
# по возрастанию
u <- seq(0, 1, 1/3)
v <- seq(0, 1, 1/7)
c(u, v)
# сортировка
w <- sort(c(u, v))
# уникальные значения
w <- unique(sort(c(u, v)))

# Напишите функцию get_fractions, которая принимает на вход два числа, m и n, и 
# возвращает аналогичный вектор, содержащий все дроби вида 
# {i/m, i = 0, 1, ..., m} и  {j/n, j = 0, 1, ..., n}. Вектор не должен содержать 
# повторов. И -- сюжетный поворот -- должен быть упорядочен в порядке убывания.

get_fractions <- function(m, n) {
  x <- seq(0, m, 1) / m
  y <- seq(0, n, 1) / n
  z <- sort(unique(c(x, y)), decreasing = T)
  return(z)
}
abv <- get_fractions(5, 7)
# [1] 1.0000000 0.8571429 0.8000000 0.7142857 0.6000000 0.5714286 0.4285714 0.4000000 0.2857143
# [10] 0.2000000 0.1428571 0.0000000

# То же самое, но короче
get_fractions <- function(m, n) {
  return(z <- sort(unique(c(seq(0, m, 1) / m, seq(0, n, 1) / n)), decreasing = T))
}
abv <- get_fractions(5, 7)
####################################


# Приведение типов происходит по цепочке слева направо:
# logical - integer - double - character
b <- c(FALSE, 1.5)
typeof(b) # [1] "double" число 1.5 стоит правее логичесой переменной

b <- c(5, b, "abc")
typeof(b) # [1] "character" строка "abc" стоит правее в цепочке
b # [1] "5"   "0"   "1.5" "abc" - все переменные превратились в строки

# Принудительное приведение типов функцией as.*
as.double(b)
# более распространенная
as.numeric(b)
# [1] 5.0 0.0 1.5  NA
# Предупреждение:
#  в результате преобразования созданы NA 


# Длина вектора length
x <- 1:100
length(x) # [1] 100
# Принудительное изменение длины вектора
length(x) <- 4; x ## [1] 1 2 3 4
length(x) <- 7; x ## [1]  1  2  3  4 NA NA NA - добавились пропущенные значения

## Именованные вектора
# Элементы вектора могут быть проименованы:
a <- c(uno = 1, dos = 2, 'universal answer' = 42, 99)
a
# uno              dos universal answer                  
# 1                2               42               99 
names(a)
# [1] "uno"              "dos"              "universal answer" ""    
# Имена не могут начинаться с цифры, если содержат спецсимволы - заключаются в двойные кавычки

# Второй способ
names(a) <- c('one', 'two', 'forty two', 'ninety nine')
a
#         one         two   forty two ninety nine 
#           1           2          42          99 


## Векторизация

sqrt(1:4) # функция квадратного корня
# [1] 1.000000 1.414214 1.732051 2.000000

floor(seq(0, 3, by = 0.25)) # округление вниз до ближайшего целого
# [1] 0 0 0 0 1 1 1 1 2 2 2 2 3

# не векторизованная функция
sum(1:100) # [1] 5050  -- сумма - одно число

#Общий глоссарий для этого урока:
# ?c, ?":"
# ?seq, ?rep
# ?print
# ?all.equal
# ?typeof
# ?is.logical, ?as.logical, etc.
# ?length, ?names













