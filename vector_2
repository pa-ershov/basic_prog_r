
## Правила переписывания (recycling) ##

# Если векторы разной длины

# 1. Длина результата равна длине большего из векторов
# 2. Меньший вектор дублируется (переписывается) несколько раз, чтобы длина переписанного вектора
#    совпала с длиной большего
# 3. Если длина большего вектора не делится нацело на длину меньшего, выдается предупреждение
#

x <- 1:5 + 0:1
# Предупреждение:
# В 1:5 + 0:1 :
#  длина большего объекта не является произведением длины меньшего объекта
# [1] 1 3 3 5 5

1:10 + 3
# [1]  4  5  6  7  8  9 10 11 12 13

(5:8) ^ 2


# Доступ к элементам вектора

x <- seq(10, 100, by = 10)
x[1]
x[-5] # Все элементы, кроме пятого

x[c(-3, -5, -length(x), -5)]
# [1] 10 20 40 60 70 80 90
# -length(x) - все элементы, кроме последнего

# Логические индексы
x[rep(c(TRUE, FALSE), 5)] # Все нечетные
# [1] 10 30 50 70 90
x[c(TRUE, FALSE)] # правило переписывания
# [1] 10 30 50 70 90
x[x > 77 & x < 99] # Диапазон
# [1] 80 90


# Функции all и any #
all(x < 200) # Все элементы меньше 200
# [1] TRUE
all(x > 20)
# [1] FALSE
any(x > 150) # Хотя бы один
# [1] FALSE
any(x > 20)
# [1] TRUE

which(x >= 50) # Индексы элементов по условию
# [1]  5  6  7  8  9 10
which.min(x) # Позиция наименьшего элемента
# [1] 1
which.max(x)
# [1] 10

# Атрибуты объектов
x <- c(5, 3, 9)
names(x) <- c("V", "III", "IX")
#   V III  IX 
#   5   3   9 
attr(x, "author") <- "Ceaser"
attributes(x)
# $names
# [1] "V"   "III" "IX"
# $author
# [1] "Ceaser"
attributes(x) <- NULL
# NULL


# Убираем каждый 7 элемент
x <- c(1,2,3,4,5,6,7,11,12,13,14,15,16,17,21,22,23,24,25,26,27)
x[c(rep(T, 6), F)]
x[1:length(x) %% 7 != 0]
x[-(1:floor(length(x)/7) * 7)]
x[-(seq(7, length(x), by = 7))]
x[1:length(x) %% 7 > 0]

y <- vector(mode = "character", length = 100)
y <- character(100)
for (i in 1:100) {
  if (i %% 15 == 0) {
    y[i] <- "fizz buzz"
  } else if (i %% 3 == 0 ) {
    y[i] <- "fizz"
  } else if (i %% 5 == 0) {
    y[i] <- "buzz"
  } else {
    y[i] <- i
  }
}

x <- 1:100
z <- 1:100
x %% 5
x %% 5 == 0
z[x %% 5 == 0] <- "buzz"
z[x %% 3 == 0] <- "fizz"
z[x %% 15 == 0 ] <- "fizz buzz"
z
all(y == z)


paste(letters[c(1, 23, 5, 19, 15, 13, 5)], collapse = "")
# [1] "awesome"

# Geometric progression
x <- 2 ^ (0:10)
# [1]    1    2    4    8   16   32   64  128  256  512 1024
log2(x)
# [1]  0  1  2  3  4  5  6  7  8  9 10

# Элементы случайности
set.seed(42) # фиксация случайных значений
RNGkind(sample.kind = "Rounding")
x <- sample(1:100, 50) # вектор случайных значений
#  [1] 92 93 29 81 62 50 70 13 61 65 42 91 83 23 40 80 88 10 39 46 73 11 78 85  7 82 98 67 33 60
# [31] 52 56 27 97  1 55 66 14 57 38 87 26  3 69 25 53 48 34 51 32
x[-1] # вектор без первого числа
x
x[-length(x)] # вектор без последнего числа
x[-1] - x[-length(x)] # попарные разницы
k <- which.max(abs(x[-1] - x[-length(x)])) # позиция максимальной разницы
x[c(k, k + 1)] # соседи с максимальной разностью
# [1] 97  1

# Multiple min/max
#А что, если у нас есть несколько таких значений в векторе?
set.seed(42)
x <- sample(1:100, 50, replace = T); x # добавляем повторы
min(x)                                 # выдает только один ээлемент, но он в векторе повторяется несколько раз
which.min(x)                           # выдаст только первое вхождение
which(x == min(x))                     
# [1] 35 37

## Функция решения задачи
maxdiff <- function(x) {
  y <- abs(x[-1] - x[-length(x)])
  # y <- abs(diff(x))                   # бонус из комментов
  k <- which(y == max(y))
  print("First neighbour(s):")
  print(x[k])
  print("Second neighbour(s):")
  print(x[k + 1])
  print("Maximum absolute diff is:")
  print(max(y))
}
xx <- sample(1:100, 1e4, replace = T)
maxdiff(xx)



# Пусть вектор называется нестрого возрастающим, если каждый следующий элемент в 
# нём не меньше, чем предыдущий. Точно так же, вектор назовём нестрого убывающим, 
# если каждый следующий элемент в нём не больше, чем предыдущий. Напишите функцию, 
# которая принимает один аргумент (числовой вектор) и возвращает TRUE, если вектор 
# обладает свойством нестрогой монотонности, то есть является либо несторого возрастающим, 
# либо нестрого убывающим. В противном случае функция возвращает FALSE.
#Пример. x=c(0, 0, 3, 4, 4, 8) нестрого возрастает, возвращаем TRUE. 
# y=c(3:0, 1) был бы нестрого убывающим, если бы не последняя единица, 
#поэтому возвращаем FALSE.

is_monotone <- function(x) {
  all(diff(x) <= 0) | all(diff(x) >= 0)
}


# Разбавим курс ложечкой комбинаторики. Пусть у нас есть n предметов, из которых 
# нужно выбрать k штук.
# Известнейшая комбинаторная формула C_n^k = \frac{n!}{k!(n-k)!}C 
# ("Цэ из эн по ка") задаёт количество всевозможных сочетаний. Похожий вид 
# имеет и количество сочетаний с повторениями (мультикомбинаций).
# Запрограммируйте оба этих значения в виде функции, зависящей от n и k. 
# Аргумент with_repetitions будет отвечать за вариант подсчёта: если он FALSE, то 
# пусть считается количество сочетаний, а если TRUE, то сочетаний с повторениями.

combin_count <- function(n, k, with_repetitions = F) {
  if (with_repetitions) {
    factorial(n + k - 1) / (factorial(k) * factorial(n - 1))
  } else {
    factorial(n) / (factorial(k) * factorial(n - k))
  }
}

# с функцией choose
combin_count <- function(n, k, with_repretitions = FALSE) {
  ifelse(with_repretitions, return(choose(n + k - 1, n - 1)), return(choose(n, k)))
}


# Общий глоссарий для этого урока:
  
# Recycling rules
# ?"+", ?Arithmetic, ?"["
# ?all, ?any
# ?which, ?which.min, ?which.max
# ?attributes
# ?sample, ?runif




